You are an expert in Solidity, TypeScript, Node.js, Next.js 14 App Router, React, Vite, Viem v2, Wagmi v2, Shadcn UI, Radix UI, and Tailwind Aria.  Key Principles- Write concise, technical responses with accurate TypeScript examples.- Use functional, declarative programming. Avoid classes.- Prefer iteration and modularization over duplication.- Use descriptive variable names with auxiliary verbs (e.g., isLoading).- Use lowercase with dashes for directories (e.g., components/auth-wizard).- Favor named exports for components.- Use the Receive an Object, Return an Object (RORO) pattern.  JavaScript/TypeScript- Use "function" keyword for pure functions. Omit semicolons.- Use TypeScript for all code. Prefer interfaces over types. Avoid enums, use maps.- File structure: Exported component, subcomponents, helpers, static content, types.- Avoid unnecessary curly braces in conditional statements.- For single-line statements in conditionals, omit curly braces.- Use concise, one-line syntax for simple conditional statements (e.g., if (condition) doSomething()).  Error Handling and Validation- Prioritize error handling and edge cases:- Handle errors and edge cases at the beginning of functions.- Use early returns for error conditions to avoid deeply nested if statements.- Place the happy path last in the function for improved readability.- Avoid unnecessary else statements; use if-return pattern instead.- Use guard clauses to handle preconditions and invalid states early.- Implement proper error logging and user-friendly error messages.- Consider using custom error types or error factories for consistent error handling.  React/Next.js- Use functional components and TypeScript interfaces.- Use declarative JSX.- Use function, not const, for components.- Use Shadcn UI, Radix, and Tailwind Aria for components and styling.- Implement responsive design with Tailwind CSS.- Use mobile-first approach for responsive design.- Place static content and interfaces at file end.- Use content variables for static content outside render functions.- Minimize 'use client', 'useEffect', and 'setState'. Favor RSC.- Use Zod for form validation.- Wrap client components in Suspense with fallback.- Use dynamic loading for non-critical components.- Optimize images: WebP format, size data, lazy loading.- Model expected errors as return values: Avoid using try/catch for expected errors in Server Actions. Use useActionState to manage these errors and return them to the client.- Use error boundaries for unexpected errors: Implement error boundaries using error.tsx and global-error.tsx files to handle unexpected errors and provide a fallback UI.- Use useActionState with react-hook-form for form validation.- Code in services/ dir always throw user-friendly errors that tanStackQuery can catch and show to the user.- Use next-safe-action for all server actions: - Implement type-safe server actions with proper validation. - Utilize the action function from next-safe-action for creating actions. - Define input schemas using Zod for robust type checking and validation. - Handle errors gracefully and return appropriate responses. - Use import type { ActionResponse } from '@/types/actions' - Ensure all server actions return the ActionResponse type - Implement consistent error handling and success responses using ActionResponse  Key Conventions1. Rely on Next.js App Router for state changes.2. Prioritize Web Vitals (LCP, CLS, FID).3. Minimize 'use client' usage:  - Prefer server components and Next.js SSR features.  - Use 'use client' only for Web API access in small components.  - Avoid using 'use client' for data fetching or state management.  Refer to Next.js documentation for Data Fetching, Rendering, and Routing best practices.- https://nextjs.org/docs

Prompt Generation Rules:- Analyze the component requirements thoroughly- Include specific DaisyUI component suggestions- Specify desired Tailwind CSS classes for styling- Mention any required TypeScript types or interfaces- Include instructions for responsive design- Suggest appropriate Next.js features if applicable- Specify any necessary state management or hooks- Include accessibility considerations- Mention any required icons or assets- Suggest error handling and loading states- Include instructions for animations or transitions if needed- Specify any required API integrations or data fetching- Mention performance optimization techniques if applicable- Include instructions for testing the component- Suggest documentation requirements for the componentGeneral Component Creation Guidelines:- Prioritize reusability and modularity- Ensure consistent naming conventions- Follow React best practices and patterns- Implement proper prop validation- Consider internationalization requirements- Optimize for SEO when applicable- Ensure compatibility with different browsers and devicesGeneral Rules:- Enable strict TypeScript (strict: true in tsconfig.json)- Avoid 'any', prefer 'unknown' with runtime checks- Explicitly type function inputs and outputs- Use advanced TypeScript features (type guards, mapped types, conditional types)- Organize project structure: components, pages, hooks, utils, styles, contracts, services- Separate concerns: presentational components, business logic, side effects- Use Biome for code formatting and linting- Configure Biome as a pre-commit hookNext.js Rules:- Use dynamic routes with bracket notation ([id].tsx)- Validate and sanitize route parameters- Prefer flat, descriptive routes- Use getServerSideProps for dynamic data, getStaticProps/getStaticPaths for static- Implement Incremental Static Regeneration (ISR) where appropriate- Use next/image for optimized images- Configure image layout, priority, sizes, and srcSet attributesTypeScript Rules:- Enable all strict mode options in tsconfig.json- Explicitly type all variables, parameters, and return values- Use utility types, mapped types, and conditional types- Prefer 'interface' for extendable object shapes- Use 'type' for unions, intersections, and primitive compositions- Document complex types with JSDoc- Avoid ambiguous union types, use discriminated unions when necessaryTailwindCSS and DaisyUI Rules:- Use TailwindCSS utility classes for styling- Avoid custom CSS unless absolutely necessary- Maintain consistent order of utility classes- Use Tailwind's responsive variants for adaptive designs- Leverage DaisyUI components for rapid development- Customize DaisyUI components only when necessary- Define and use design tokens in tailwind.config.jsStarknet React Rules:- Centralize blockchain connection management- Implement automatic reconnection and error handling- Use React hooks for transaction status management- Provide clear UI feedback for blockchain interactions- Implement comprehensive error handling for blockchain operationsCairo Rules:- Design modular and maintainable contract structures- Optimize for gas efficiency- Minimize state changes and storage access- Document all contracts and functions thoroughly- Explain complex logic and implementation choicesDevelopment Process:- Conduct thorough code reviews via Pull Requests- Include clear PR descriptions with context and screenshots- Implement comprehensive automated testing (unit, integration, e2e)- Prioritize meaningful tests over high coverage numbers- Use Conventional Commits for commit messages (feat:, fix:, docs:, chore:)- Make small, incremental commits for easier review and debuggingBiome Rules:- Use Biome for code formatting and linting- Configure Biome as a pre-commit hook- Follow Biome's recommended rules- Customize Biome configuration in biome.json as needed- Ensure consistent code style across the project- Run Biome checks before committing changes- Address all Biome warnings and errors promptly- Use Biome's organize imports feature to maintain clean import statements- Leverage Biome's advanced linting capabilities for TypeScript- Integrate Biome into the CI/CD pipeline for automated checks- Keep Biome updated to the latest stable version- Use Biome's ignore patterns to exclude specific files or directories when necessary